from __future__ import annotations

from typing import List, Optional
from uuid import uuid4

from pentest_schemas import (
    PentestTask,
    AgentResult,
    Finding,
    Evidence,
    Confidence,
    Severity,
    FindingStatus,
)
from agents.base import BasePentestAgent, AgentContext

try:
    from langgraph.graph import StateGraph, END
    from langgraph.graph.state import CompiledStateGraph
except Exception:  # pragma: no cover
    StateGraph = None  # type: ignore
    END = None  # type: ignore
    CompiledStateGraph = None  # type: ignore


def _gen_id() -> str:
    return uuid4().hex


class ExploitAgent(BasePentestAgent):
    """Proof-of-Concept exploitation agent (MVP: SQLi confirmation via sqlmap).

    - Uses sqlmap in confirm mode to minimally verify exploitation without destructive actions
    - Targets URLs provided in the task (typically derived from ScanAgent)
    - Emits confirmed Findings with trimmed stdout as evidence
    """

    def __init__(self, tools: Optional[List] = None):
        super().__init__(name="exploit", tools=tools)

    async def _execute(self, task: PentestTask, result: AgentResult, ctx: AgentContext) -> None:
        urls: List[str] = task.urls or []
        sqlmap = ctx.tools.get("sqlmap")
        if not urls:
            self.log(result, "No URLs supplied for exploitation")
            return

        if sqlmap is None or not await sqlmap.available():
            self.log(result, "sqlmap not available on PATH; skipping SQLi confirmation")
            return

        confirm_switches = [
            "--batch",
            "--level",
            "1",
            "--risk",
            "1",
            "--flush-session",
            "--banner",
            "--current-user",
            "--is-dba",
        ]

        for u in urls[:5]:  # cap for MVP
            res = await sqlmap.run(args=["-u", u, *confirm_switches], timeout=float(task.params.get("sqlmap_timeout", 120)))
            result.metrics.tool_invocations["sqlmap"] = result.metrics.tool_invocations.get("sqlmap", 0) + 1
            result.logs.append(
                f"[sqlmap:exploit] cmd={res.get('cmd')} exit={res.get('exit_code')} timed_out={res.get('timed_out')}"
            )

            stdout = (res.get("stdout") or "")[:4000]
            if self._looks_confirmed(stdout):
                finding = Finding(
                    id=_gen_id(),
                    category="sqli",
                    title="Confirmed SQL injection via sqlmap",
                    description="sqlmap retrieved banner/current-user or DBA status, indicating successful exploitation",
                    url=u,
                    confidence=Confidence.HIGH,
                    severity=Severity.HIGH,
                    status=FindingStatus.CONFIRMED,
                    source_tool="sqlmap",
                    evidence=[Evidence(notes=stdout)],
                )
                result.findings.append(finding)

    def _looks_confirmed(self, out: str) -> bool:
        low = out.lower()
        return any(
            key in low
            for key in [
                "current user:",
                "banner:",
                "is dba:",
                "parameter",
                "following injection point(s) found",
            ]
        )

    def _build_graph(self) -> Optional[CompiledStateGraph]:
        if StateGraph is None:
            return None

        g = StateGraph(dict)

        async def prepare(state: Dict[str, Any]) -> Dict[str, Any]:
            task: PentestTask = state["task"]
            result: AgentResult = state["result"]
            urls: List[str] = task.urls or []
            state["urls"] = urls
            if not urls:
                self.log(result, "No URLs supplied for exploitation")
            return state

        async def confirm_sqlmap(state: Dict[str, Any]) -> Dict[str, Any]:
            task: PentestTask = state["task"]
            result: AgentResult = state["result"]
            ctx: AgentContext = state["ctx"]
            urls: List[str] = state.get("urls", [])
            sqlmap = ctx.tools.get("sqlmap")
            if not urls:
                return state
            if sqlmap is None or not await sqlmap.available():
                self.log(result, "sqlmap not available on PATH; skipping SQLi confirmation")
                return state
            confirm_switches = [
                "--batch", "--level", "1", "--risk", "1", "--flush-session", "--banner", "--current-user", "--is-dba",
            ]
            for u in urls[:5]:
                res = await sqlmap.run(args=["-u", u, *confirm_switches], timeout=float(task.params.get("sqlmap_timeout", 120)))
                result.metrics.tool_invocations["sqlmap"] = result.metrics.tool_invocations.get("sqlmap", 0) + 1
                result.logs.append(
                    f"[sqlmap:exploit] cmd={res.get('cmd')} exit={res.get('exit_code')} timed_out={res.get('timed_out')}"
                )
                stdout = (res.get("stdout") or "")[:4000]
                if self._looks_confirmed(stdout):
                    finding = Finding(
                        id=_gen_id(),
                        category="sqli",
                        title="Confirmed SQL injection via sqlmap",
                        description="sqlmap retrieved banner/current-user or DBA status, indicating successful exploitation",
                        url=u,
                        confidence=Confidence.HIGH,
                        severity=Severity.HIGH,
                        status=FindingStatus.CONFIRMED,
                        source_tool="sqlmap",
                        evidence=[Evidence(notes=stdout)],
                    )
                    result.findings.append(finding)
            return state

        g.add_node("prepare", prepare)
        g.add_node("confirm_sqlmap", confirm_sqlmap)
        g.set_entry_point("prepare")
        g.add_edge("prepare", "confirm_sqlmap")
        g.add_edge("confirm_sqlmap", END)
        return g.compile()


__all__ = ["ExploitAgent"]
